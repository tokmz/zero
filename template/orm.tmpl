{{define "orm"}}
// Code generated by github.com/tokmz/zero. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"fmt"
	"time"

	"github.com/zeromicro/go-zero/core/logx"
	"go.opentelemetry.io/otel/attribute"
	oteltrace "go.opentelemetry.io/otel/trace"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"gorm.io/plugin/dbresolver"
)

var db *gorm.DB

// Config 数据库配置
type Config struct {
	// Master 主库配置，用于处理写操作和事务
	Master DSNConfig

	// Slaves 从库配置列表，用于处理读操作，支持多个从库实现负载均衡
	Slaves []DSNConfig

	// MaxOpenConns 数据库连接池最大连接数
	// 限制与数据库建立的最大连接数，避免因连接数过多导致数据库负载过高
	MaxOpenConns int

	// MaxIdleConns 数据库连接池最大空闲连接数
	// 设置合理的空闲连接数可以避免频繁的连接创建和销毁，提高性能
	MaxIdleConns int

	// MaxLifetime 连接的最大生命周期
	// 超过这个时间的连接将被关闭，有助于及时释放长时间未使用的连接
	MaxLifetime time.Duration

	// Sources 分库配置列表
	// 每个 Source 包含一个独立的主从库配置，用于实现分库分表
	Sources []SourceConfig

	// Policy 从库负载均衡策略
	// 可选值：
	// - "random": 随机选择从库
	// - "round": 轮询方式选择从库
	Policy string

	// Tables 当前数据源适用的表名列表
	// 为空时表示应用于所有表
	// 用于配置特定表的读写分离规则
	Tables []string
}

// DSNConfig 数据源配置
type DSNConfig struct {
	DSN string // 数据源连接串，格式：user:pass@tcp(host:port)/dbname?charset=utf8mb4&parseTime=True&loc=Local
}

// SourceConfig 数据源配置
type SourceConfig struct {
	Master   DSNConfig
	Replicas []DSNConfig
	Tables   []string
}

// NewMysql 创建MySQL实例，支持读写分离
// 主库用于处理写操作和事务
// 从库用于处理读操作，支持多个从库和负载均衡
func NewMysql(c Config) error {
	if c.Master.DSN == "" {
		return fmt.Errorf("master dsn required")
	}

	// 连接主库
	var err error
	db, err = gorm.Open(mysql.Open(c.Master.DSN), &gorm.Config{
		Logger: NewLogger(),
	})
	if err != nil {
		return fmt.Errorf("connect master failed: %v", err)
	}

	// 只有配置了从库时才设置读写分离
	if len(c.Slaves) > 0 {
		// 配置读写分离
		resolver := dbresolver.Register(dbresolver.Config{
			Sources:  []gorm.Dialector{mysql.Open(c.Master.DSN)},
			Replicas: buildReplicaDialectors(c.Slaves),
			Policy:   buildPolicy(c.Policy),
		})

		// 配置其他数据源的读写分离
		for i := 0; i < len(c.Sources); i++ {
			// 只有配置了从库时才设置该数据源的读写分离
			if len(c.Sources[i].Replicas) > 0 {
				tables := make([]interface{}, len(c.Tables))
				for j := range c.Tables {
					tables[j] = c.Tables[j]
				}
				resolver = resolver.Register(dbresolver.Config{
					Sources:  []gorm.Dialector{mysql.Open(c.Sources[i].Master.DSN)},
					Replicas: buildReplicaDialectors(c.Sources[i].Replicas),
				}, tables...)
			}
		}

		// 使用读写分离插件
		if err = db.Use(resolver); err != nil {
			return fmt.Errorf("use dbresolver failed: %v", err)
		}
	}

	sqlDB, err := db.DB()
	if err != nil {
		return err
	}

	// 设置连接池
	if c.MaxIdleConns > 0 {
		sqlDB.SetMaxIdleConns(c.MaxIdleConns)
	}
	if c.MaxOpenConns > 0 {
		sqlDB.SetMaxOpenConns(c.MaxOpenConns)
	}
	if c.MaxLifetime > 0 {
		sqlDB.SetConnMaxLifetime(c.MaxLifetime)
	}

	// 使用链路追踪插件
	if err = db.Use(&TracePlugin{}); err != nil {
		return err
	}

	return nil
}

// buildReplicaDialectors 构建从库连接
func buildReplicaDialectors(slaves []DSNConfig) []gorm.Dialector {
	replicas := make([]gorm.Dialector, 0, len(slaves))
	for _, slave := range slaves {
		replicas = append(replicas, mysql.Open(slave.DSN))
	}
	return replicas
}

// buildPolicy 构建负载均衡策略
func buildPolicy(policyType string) dbresolver.Policy {
	if policyType == "random" {
		return dbresolver.RandomPolicy{}
	}
	return dbresolver.RoundRobinPolicy()
}

// Logger 实现 gorm logger 接口
type Logger struct {
	logger.Interface
}

// NewLogger 创建日志实例
func NewLogger() logger.Interface {
	return &Logger{}
}

// LogMode 设置日志级别
func (l *Logger) LogMode(level logger.LogLevel) logger.Interface {
	return l
}

// Info 信息日志
func (l *Logger) Info(ctx context.Context, msg string, args ...interface{}) {
	logx.WithContext(ctx).Infof(msg, args...)
}

// Warn 警告日志
func (l *Logger) Warn(ctx context.Context, msg string, args ...interface{}) {
	logx.WithContext(ctx).Errorf(msg, args...)
}

// Error 错误日志
func (l *Logger) Error(ctx context.Context, msg string, args ...interface{}) {
	logx.WithContext(ctx).Errorf(msg, args...)
}

// Trace 跟踪日志
func (l *Logger) Trace(ctx context.Context, begin time.Time, fc func() (sql string, rowsAffected int64), err error) {
	elapsed := time.Since(begin)
	sql, rows := fc()

	if err != nil {
		logx.WithContext(ctx).Errorf("[%.3fms] [rows:%v] %s, %s", float64(elapsed.Nanoseconds())/1e6, rows, sql, err.Error())
	} else {
		logx.WithContext(ctx).Infof("[%.3fms] [rows:%v] %s", float64(elapsed.Nanoseconds())/1e6, rows, sql)
	}
}

// TracePlugin 链路追踪插件
type TracePlugin struct{}

// Name 插件名称
func (op *TracePlugin) Name() string {
	return "TracePlugin"
}

// Initialize 初始化插件
func (op *TracePlugin) Initialize(db *gorm.DB) error {
	// 开始前
	_ = db.Callback().Create().Before("gorm:create").Register("trace_before_create", op.before)
	_ = db.Callback().Query().Before("gorm:query").Register("trace_before_query", op.before)
	_ = db.Callback().Delete().Before("gorm:delete").Register("trace_before_delete", op.before)
	_ = db.Callback().Update().Before("gorm:update").Register("trace_before_update", op.before)
	_ = db.Callback().Row().Before("gorm:row").Register("trace_before_row", op.before)
	_ = db.Callback().Raw().Before("gorm:raw").Register("trace_before_raw", op.before)

	// 完成后
	_ = db.Callback().Create().After("gorm:create").Register("trace_after_create", op.after)
	_ = db.Callback().Query().After("gorm:query").Register("trace_after_query", op.after)
	_ = db.Callback().Delete().After("gorm:delete").Register("trace_after_delete", op.after)
	_ = db.Callback().Update().After("gorm:update").Register("trace_after_update", op.after)
	_ = db.Callback().Row().After("gorm:row").Register("trace_after_row", op.after)
	_ = db.Callback().Raw().After("gorm:raw").Register("trace_after_raw", op.after)
	return nil
}

// 请求前的处理
func (op *TracePlugin) before(db *gorm.DB) {
	ctx := db.Statement.Context
	if ctx == nil {
		return
	}

	span := oteltrace.SpanFromContext(ctx)
	if !span.IsRecording() {
		return
	}

	db.InstanceSet("span", span)
}

// 请求后的处理
func (op *TracePlugin) after(db *gorm.DB) {
	_span, isExist := db.InstanceGet("span")
	if !isExist {
		return
	}

	span, ok := _span.(oteltrace.Span)
	if !ok {
		return
	}

	defer span.End()

	// 记录sql和参数
	span.SetAttributes(
		attribute.String("sql", db.Statement.SQL.String()),
		attribute.String("vars", fmt.Sprintf("%v", db.Statement.Vars)),
		attribute.Int64("rowsAffected", db.Statement.RowsAffected),
	)

	if db.Statement.Error != nil {
		span.SetAttributes(attribute.String("error", db.Statement.Error.Error()))
	}
}

// Ping 检查数据库连接是否正常
func Ping() error {
	sqlDB, err := db.DB()
	if err != nil {
		return err
	}
	return sqlDB.Ping()
}
{{end}} 