{{define "orm"}}
// Code generated by github.com/tokmz/zero. DO NOT EDIT.

package {{.Package}}

import (
	"fmt"
	"log"
	"os"
	"time"

	"go.opentelemetry.io/otel/attribute"
	oteltrace "go.opentelemetry.io/otel/trace"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"gorm.io/gorm/schema"
	"gorm.io/plugin/dbresolver"
)

// Config 数据库配置
type Config struct {
	// Master 主库配置，用于处理写操作和事务
	Master string // 数据源连接串，格式：user:pass@tcp(host:port)/dbname?charset=utf8mb4&parseTime=True&loc=Local

	// Slaves 从库配置列表，用于处理读操作，支持多个从库实现负载均衡
	Slaves []string

	// MaxOpenConns 数据库连接池最大连接数
	// 限制与数据库建立的最大连接数，避免因连接数过多导致数据库负载过高
	MaxOpenConns int

	// MaxIdleConns 数据库连接池最大空闲连接数
	// 设置合理的空闲连接数可以避免频繁的连接创建和销毁，提高性能
	MaxIdleConns int

	// MaxLifetime 连接的最大生命周期
	// 超过这个时间的连接将被关闭，有助于及时释放长时间未使用的连接
	MaxLifetime time.Duration

	// Sources 分库配置列表
	// 每个 Source 包含一个独立的主从库配置，用于实现分库分表
	Sources []SourceConfig

	// Policy 从库负载均衡策略
	// 可选值：
	// - "random": 随机选择从库
	// - "round": 轮询方式选择从库
	Policy string

	// Tables 当前数据源适用的表名列表
	// 为空时表示应用于所有表
	// 用于配置特定表的读写分离规则
	Tables []string

	// SlowThreshold 慢查询阈值
	SlowThreshold time.Duration

	// LogLevel 日志级别
	LogLevel logger.LogLevel

	// EnableLog 是否启用SQL日志
	EnableLog bool
}

// SourceConfig 数据源配置
type SourceConfig struct {
	Master   string
	Replicas []string
	Tables   []string
}

// NewMysql 创建MySQL实例，支持读写分离
// 主库用于处理写操作和事务
// 从库用于处理读操作，支持多个从库和负载均衡
func NewMysql(c Config) (*gorm.DB, error) {
	if c.Master == "" {
		return nil, fmt.Errorf("master dsn required")
	}

	var logLevel logger.LogLevel
	if !c.EnableLog {
		logLevel = logger.Silent
	} else {
		logLevel = c.LogLevel
	}

	gormConfig := &gorm.Config{
		Logger: logger.New(
			log.New(os.Stdout, "\r\n", log.LstdFlags),
			logger.Config{
				SlowThreshold:             c.SlowThreshold,
				LogLevel:                  logLevel,
				IgnoreRecordNotFoundError: true,
				Colorful:                  true,
			},
		),
		NamingStrategy: &schema.NamingStrategy{
			SingularTable: true, // 使用单数表名
		},
		PrepareStmt: true, // 缓存预编译语句
	}

	db, err := gorm.Open(mysql.Open(c.Master), gormConfig)
	if err != nil {
		return nil, fmt.Errorf("connect master failed: %v", err)
	}

	// 配置读写分离
	if len(c.Slaves) > 0 {
		resolver := dbresolver.Register(dbresolver.Config{
			Sources:  []gorm.Dialector{mysql.Open(c.Master)},
			Replicas: buildReplicaDialectors(c.Slaves),
			Policy:   buildPolicy(c.Policy),
		})

		// 配置其他数据源
		for _, source := range c.Sources {
			if len(source.Replicas) > 0 {
				tables := make([]interface{}, len(source.Tables))
				for i := range source.Tables {
					tables[i] = source.Tables[i]
				}
				resolver = resolver.Register(dbresolver.Config{
					Sources:  []gorm.Dialector{mysql.Open(source.Master)},
					Replicas: buildReplicaDialectors(source.Replicas),
				}, tables...)
			}
		}

		if err = db.Use(resolver); err != nil {
			return nil, fmt.Errorf("use dbresolver failed: %v", err)
		}
	}

	sqlDB, err := db.DB()
	if err != nil {
		return nil, err
	}

	// 设置连接池
	if c.MaxIdleConns > 0 {
		sqlDB.SetMaxIdleConns(c.MaxIdleConns)
	}
	if c.MaxOpenConns > 0 {
		sqlDB.SetMaxOpenConns(c.MaxOpenConns)
	}
	if c.MaxLifetime > 0 {
		sqlDB.SetConnMaxLifetime(c.MaxLifetime)
	}

	// 使用插件
	if err = db.Use(&TracePlugin{}); err != nil {
		return nil, err
	}

	return db, nil
}

// TracePlugin 链路追踪插件
type TracePlugin struct{}

func (op *TracePlugin) Name() string {
	return "TracePlugin"
}

func (op *TracePlugin) Initialize(db *gorm.DB) error {
	// 注册回调
	callbacks := []string{"create", "query", "update", "delete", "row", "raw"}
	
	for _, callback := range callbacks {
		switch callback {
		case "create":
			_ = db.Callback().Create().Register("trace_plugin:before_create", op.trace)
		case "query":
			_ = db.Callback().Query().Register("trace_plugin:before_query", op.trace)
		case "update":
			_ = db.Callback().Update().Register("trace_plugin:before_update", op.trace)
		case "delete":
			_ = db.Callback().Delete().Register("trace_plugin:before_delete", op.trace)
		case "row":
			_ = db.Callback().Row().Register("trace_plugin:before_row", op.trace)
		case "raw":
			_ = db.Callback().Raw().Register("trace_plugin:before_raw", op.trace)
		}
	}
	
	return nil
}

func (op *TracePlugin) trace(db *gorm.DB) {
	ctx := db.Statement.Context
	if ctx == nil {
		return
	}

	span := oteltrace.SpanFromContext(ctx)
	if !span.IsRecording() {
		return
	}

	// 添加 SQL 相关属性
	attrs := []attribute.KeyValue{
		attribute.String("db.system", "mysql"),
		attribute.String("db.statement", db.Statement.SQL.String()),
		attribute.Int64("db.rows_affected", db.Statement.RowsAffected),
	}

	if db.Statement.Error != nil {
		attrs = append(attrs, attribute.String("error", db.Statement.Error.Error()))
	}

	span.SetAttributes(attrs...)
}

// buildReplicaDialectors 构建从库连接
func buildReplicaDialectors(slaves []string) []gorm.Dialector {
	replicas := make([]gorm.Dialector, 0, len(slaves))
	for _, slave := range slaves {
		replicas = append(replicas, mysql.Open(slave))
	}
	return replicas
}

// buildPolicy 构建负载均衡策略
func buildPolicy(policyType string) dbresolver.Policy {
	if policyType == "random" {
		return dbresolver.RandomPolicy{}
	}
	return dbresolver.RoundRobinPolicy()
}

// Ping 检查数据库连接是否正常
func Ping(db *gorm.DB) error {
	sqlDB, err := db.DB()
	if err != nil {
		return err
	}
	return sqlDB.Ping()
}
{{end}} 