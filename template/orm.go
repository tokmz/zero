package template

/*
   @NAME    : orm
   @author  : 清风
   @desc    :
   @time    : 2025/2/7 11:11
*/

// OrmTemplate 默认模板
const OrmTemplate = `{{define "orm"}}
// Code generated by github.com/tokmz/zero. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"fmt"
	"time"

	"github.com/zeromicro/go-zero/core/logx"
	"go.opentelemetry.io/otel/attribute"
	oteltrace "go.opentelemetry.io/otel/trace"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"gorm.io/gorm/schema"
	"gorm.io/plugin/dbresolver"
)

// Config 数据库配置
type Config struct {
	// Master 主库配置，用于处理写操作和事务
	Master DSNConfig

	// Slaves 从库配置列表，用于处理读操作，支持多个从库实现负载均衡
	Slaves []DSNConfig

	// MaxOpenConns 数据库连接池最大连接数
	// 限制与数据库建立的最大连接数，避免因连接数过多导致数据库负载过高
	MaxOpenConns int

	// MaxIdleConns 数据库连接池最大空闲连接数
	// 设置合理的空闲连接数可以避免频繁的连接创建和销毁，提高性能
	MaxIdleConns int

	// MaxLifetime 连接的最大生命周期
	// 超过这个时间的连接将被关闭，有助于及时释放长时间未使用的连接
	MaxLifetime time.Duration

	// Sources 分库配置列表
	// 每个 Source 包含一个独立的主从库配置，用于实现分库分表
	Sources []SourceConfig

	// Policy 从库负载均衡策略
	// 可选值：
	// - "random": 随机选择从库
	// - "weight": 权重随机选择从库
	// - "round": 轮询方式选择从库
	Policy string

	// Tables 当前数据源适用的表名列表
	// 为空时表示应用于所有表
	// 用于配置特定表的读写分离规则
	Tables []string

	// SlowThreshold 慢查询阈值
	SlowThreshold time.Duration

	// LogLevel 日志级别
	LogLevel logger.LogLevel
}

// DSNConfig 数据源配置
type DSNConfig struct {
	DSN string // 数据源连接串，格式：user:pass@tcp(host:port)/dbname?charset=utf8mb4&parseTime=True&loc=Local
}

// SourceConfig 数据源配置
type SourceConfig struct {
	Master   DSNConfig
	Replicas []DSNConfig
	Tables   []string
}

// NewMysql 创建MySQL实例，支持读写分离
// 主库用于处理写操作和事务
// 从库用于处理读操作，支持多个从库和负载均衡
func NewMysql(c Config) (*gorm.DB, error) {
	if c.Master.DSN == "" {
		return nil, fmt.Errorf("master dsn required")
	}

	gormConfig := &gorm.Config{
		Logger: NewLogger(c.LogLevel, c.SlowThreshold),
		NamingStrategy: &schema.NamingStrategy{
			SingularTable: true,  // 使用单数表名
		},
		PrepareStmt: true,       // 缓存预编译语句
	}

	db, err := gorm.Open(mysql.Open(c.Master.DSN), gormConfig)
	if err != nil {
		return nil, fmt.Errorf("connect master failed: %v", err)
	}

	// 配置读写分离
	if len(c.Slaves) > 0 {
		resolver := dbresolver.Register(dbresolver.Config{
			Sources:  []gorm.Dialector{mysql.Open(c.Master.DSN)},
			Replicas: buildReplicaDialectors(c.Slaves),
			Policy:   buildPolicy(c.Policy),
		})

		// 配置其他数据源
		for _, source := range c.Sources {
			if len(source.Replicas) > 0 {
				tables := make([]interface{}, len(source.Tables))
				for i := range source.Tables {
					tables[i] = source.Tables[i]
				}
				resolver = resolver.Register(dbresolver.Config{
					Sources:  []gorm.Dialector{mysql.Open(source.Master.DSN)},
					Replicas: buildReplicaDialectors(source.Replicas),
				}, tables...)
			}
		}

		if err = db.Use(resolver); err != nil {
			return nil, fmt.Errorf("use dbresolver failed: %v", err)
		}
	}

	sqlDB, err := db.DB()
	if err != nil {
		return nil, err
	}

	// 设置连接池
	if c.MaxIdleConns > 0 {
		sqlDB.SetMaxIdleConns(c.MaxIdleConns)
	}
	if c.MaxOpenConns > 0 {
		sqlDB.SetMaxOpenConns(c.MaxOpenConns)
	}
	if c.MaxLifetime > 0 {
		sqlDB.SetConnMaxLifetime(c.MaxLifetime)
	}

	// 使用插件
	if err = db.Use(&TracePlugin{}); err != nil {
		return nil, err
	}

	return db, nil
}

// Logger GORM 日志实现
type Logger struct {
	logger.Interface
	LogLevel      logger.LogLevel
	SlowThreshold time.Duration
}

// NewLogger 创建日志实例
func NewLogger(level logger.LogLevel, slowThreshold time.Duration) logger.Interface {
	return &Logger{
		LogLevel:      level,
		SlowThreshold: slowThreshold,
	}
}

func (l *Logger) LogMode(level logger.LogLevel) logger.Interface {
	newLogger := *l
	newLogger.LogLevel = level
	return &newLogger
}

func (l *Logger) Info(ctx context.Context, msg string, args ...interface{}) {
	if l.LogLevel >= logger.Info {
		logx.WithContext(ctx).Infof(msg, args...)
	}
}

func (l *Logger) Warn(ctx context.Context, msg string, args ...interface{}) {
	if l.LogLevel >= logger.Warn {
		logx.WithContext(ctx).Slowf(msg, args...)
	}
}

func (l *Logger) Error(ctx context.Context, msg string, args ...interface{}) {
	if l.LogLevel >= logger.Error {
		logx.WithContext(ctx).Errorf(msg, args...)
	}
}

func (l *Logger) Trace(ctx context.Context, begin time.Time, fc func() (sql string, rowsAffected int64), err error) {
	if l.LogLevel <= logger.Silent {
		return
	}

	elapsed := time.Since(begin)
	sql, rows := fc()
	
	// 构建日志内容
	logContent := fmt.Sprintf("[%.3fms] [rows:%v] %s", float64(elapsed.Nanoseconds())/1e6, rows, sql)
	
	switch {
	case err != nil && l.LogLevel >= logger.Error:
		logx.WithContext(ctx).Errorf("%s, %s", logContent, err.Error())
	case elapsed > l.SlowThreshold && l.SlowThreshold != 0 && l.LogLevel >= logger.Warn:
		logx.WithContext(ctx).Slowf("%s", logContent)
	case l.LogLevel >= logger.Info:
		logx.WithContext(ctx).Infof("%s", logContent)
	}
}

// TracePlugin 链路追踪插件
type TracePlugin struct{}

func (op *TracePlugin) Name() string {
	return "TracePlugin"
}

func (op *TracePlugin) Initialize(db *gorm.DB) error {
	// 注册回调
	callbacks := []string{"create", "query", "update", "delete", "row", "raw"}
	
	for _, callback := range callbacks {
		switch callback {
		case "create":
			_ = db.Callback().Create().Register("trace_plugin:before_create", op.trace)
		case "query":
			_ = db.Callback().Query().Register("trace_plugin:before_query", op.trace)
		case "update":
			_ = db.Callback().Update().Register("trace_plugin:before_update", op.trace)
		case "delete":
			_ = db.Callback().Delete().Register("trace_plugin:before_delete", op.trace)
		case "row":
			_ = db.Callback().Row().Register("trace_plugin:before_row", op.trace)
		case "raw":
			_ = db.Callback().Raw().Register("trace_plugin:before_raw", op.trace)
		}
	}
	
	return nil
}

func (op *TracePlugin) trace(db *gorm.DB) {
	ctx := db.Statement.Context
	if ctx == nil {
		return
	}

	span := oteltrace.SpanFromContext(ctx)
	if !span.IsRecording() {
		return
	}

	// 添加 SQL 相关属性
	attrs := []attribute.KeyValue{
		attribute.String("db.system", "mysql"),
		attribute.String("db.statement", db.Statement.SQL.String()),
		attribute.Int64("db.rows_affected", db.Statement.RowsAffected),
	}

	if db.Statement.Error != nil {
		attrs = append(attrs, attribute.String("error", db.Statement.Error.Error()))
	}

	span.SetAttributes(attrs...)
}

// buildReplicaDialectors 构建从库连接
func buildReplicaDialectors(slaves []DSNConfig) []gorm.Dialector {
	replicas := make([]gorm.Dialector, 0, len(slaves))
	for _, slave := range slaves {
		replicas = append(replicas, mysql.Open(slave.DSN))
	}
	return replicas
}

// buildPolicy 构建负载均衡策略
func buildPolicy(policyType string) dbresolver.Policy {
	if policyType == "random" {
		return dbresolver.RandomPolicy{}
	}
	return dbresolver.RoundRobinPolicy()
}

// Ping 检查数据库连接是否正常
func Ping(db *gorm.DB) error {
	sqlDB, err := db.DB()
	if err != nil {
		return err
	}
	return sqlDB.Ping()
}
{{end}}`
